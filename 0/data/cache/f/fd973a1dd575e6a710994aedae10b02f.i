a:66:{i:0;a:3:{i:0;s:14:"document_start";i:1;a:0:{}i:2;i:0;}i:1;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:25:"长期分支/产品分支";i:1;i:3;i:2;i:1;}i:2;i:1;}i:2;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:1;}i:3;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1;}i:4;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:350:"由于 Git 使用简单的三方合并，所以就算在较长一段时间内，反复多次把某个分支合并到另一分支，也不是什么难事。也就是说，你可以同时拥有多个开放的分支，每个分支用于完成特定的任务，随着开发的推进，你可以随时把某个特性分支的成果并到其他分支中。";}i:2;i:36;}i:5;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:386;}i:6;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:386;}i:7;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:114:"这种分支长期保留，一直到产品声明周期结束。常用作产品官方库，长期开发分支等。";}i:2;i:388;}i:8;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:502;}i:9;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:502;}i:10;a:3:{i:0;s:13:"internalmedia";i:1;a:7:{i:0;s:34:":git_branch_model:bg2012070503.png";i:1;s:0:"";i:2;s:4:"left";i:3;s:3:"100";i:4;N;i:5;s:5:"cache";i:6;s:7:"details";}i:2;i:504;}i:11;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:2:"  ";}i:2;i:548;}i:12;a:3:{i:0;s:13:"internalmedia";i:1;a:7:{i:0;s:34:":git_branch_model:bg2012070504.png";i:1;s:0:"";i:2;s:5:"right";i:3;s:3:"200";i:4;N;i:5;s:5:"cache";i:6;s:7:"details";}i:2;i:550;}i:13;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:594;}i:14;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:596;}i:15;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:25:"短期分支/任务分支";i:1;i:3;i:2;i:596;}i:2;i:596;}i:16;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:596;}i:17;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:596;}i:18;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:388:"在任何规模的项目中都可以使用特性（Topic）分支。一个特性分支是指一个短期的，用来实现单一特性或与其相关工作的分支。可能你在以前的版本控制系统里从未做过类似这样的事情，因为通常创建与合并分支消耗太大。然而在 Git 中，一天之内建立、使用、合并再删除多个分支是常见的事。";}i:2;i:631;}i:19;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1019;}i:20;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1019;}i:21;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:90:"完成任务就删除的分支，常用作缺陷修复，紧急补丁，试验分支等。";}i:2;i:1021;}i:22;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1111;}i:23;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1111;}i:24;a:3:{i:0;s:13:"internalmedia";i:1;a:7:{i:0;s:34:":git_branch_model:bg2012070507.png";i:1;s:0:"";i:2;s:6:"center";i:3;s:3:"150";i:4;N;i:5;s:5:"cache";i:6;s:7:"details";}i:2;i:1113;}i:25;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1158;}i:26;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1161;}i:27;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:25:"远程分支/跟踪分支";i:1;i:3;i:2;i:1161;}i:2;i:1161;}i:28;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:1161;}i:29;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1161;}i:30;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:231:"在Git中‘追踪分支’是用与联系本地分支和远程分支的. 如果你在’追踪分支'(Tracking Branches)上执行推送(push)或拉取(pull)时,　它会自动推送(push)或拉取(pull)到关联的远程分支上.";}i:2;i:1196;}i:31;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1427;}i:32;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1427;}i:33;a:3:{i:0;s:13:"internalmedia";i:1;a:7:{i:0;s:30:":git_branch_model:wl_nrpqs.jpg";i:1;s:1:" ";i:2;s:6:"center";i:3;s:3:"300";i:4;N;i:5;s:5:"cache";i:6;s:7:"details";}i:2;i:1429;}i:34;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1471;}i:35;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1471;}i:36;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:94:"如果你经常要从远程仓库里拉取(pull)分支到本地,并且不想很麻烦的使用";}i:2;i:1473;}i:37;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:1567;}i:38;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:9:"git pull ";}i:2;i:1568;}i:39;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:1577;}i:40;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:71:"这种格式; 那么就应当使用‘追踪分支'(Tracking Branches).";}i:2;i:1578;}i:41;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1649;}i:42;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1649;}i:43;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:176:"‘git clone‘命令会自动在本地建立一个'master'分支，它是'origin/master'的‘追踪分支’. 而'origin/master'就是被克隆(clone)仓库的'master'分支.";}i:2;i:1651;}i:44;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1827;}i:45;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1827;}i:46;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:57:"译者注: origin一般是指原始仓库地址的别名.";}i:2;i:1829;}i:47;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1886;}i:48;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1886;}i:49;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:46:"你可以在使用'git branch'命令时加上'";}i:2;i:1888;}i:50;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"--";}i:2;i:1934;}i:51;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:62:"track'参数, 来手动创建一个'追踪分支'.
git branch ";}i:2;i:1936;}i:52;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"--";}i:2;i:1998;}i:53;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:38:"track experimental origin/experimental";}i:2;i:2000;}i:54;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2038;}i:55;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2038;}i:56;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:49:"当你运行下命令时:
$ git pull experimental";}i:2;i:2041;}i:57;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2090;}i:58;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2090;}i:59;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:135:"它会自动从‘origin'抓取(fetch)内容，再把远程的'origin/experimental'分支合并进(merge)本地的'experimental'分支.";}i:2;i:2093;}i:60;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2228;}i:61;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2228;}i:62;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:168:"当要把修改推送(push)到origin时, 它会将你本地的'experimental'分支中的修改推送到origin的‘experimental'分支里,　而无需指定它(origin).";}i:2;i:2230;}i:63;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2398;}i:64;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:2399;}i:65;a:3:{i:0;s:12:"document_end";i:1;a:0:{}i:2;i:2399;}}