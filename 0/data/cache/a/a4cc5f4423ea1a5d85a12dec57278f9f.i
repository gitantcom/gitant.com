a:82:{i:0;a:3:{i:0;s:14:"document_start";i:1;a:0:{}i:2;i:0;}i:1;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:33:"如何识别git中的一次提交";i:1;i:2;i:2;i:1;}i:2;i:1;}i:2;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:1;}i:3;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1;}i:4;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:350:"版本控制中准确标识出某次变更是基本功能。比如，创建分支时，要选择某次提交点作为分叉点; 输入两次版本号才能比较并行开发的代码；修改git提交的历史，也需要先收集提交版本记录。git里，你确定一次提交既可以用明确的标识，也可以用相对的关系来标识。";}i:2;i:47;}i:5;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:397;}i:6;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:397;}i:7;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:229:"唯一的，40位十六进制的SHA1值是明确的标识，HEAD，在git里指的是最近一次提交，它是隐式应用。很对时候，这种方式更方便。Git提供了很多种这种隐式应用来标识一次提交。";}i:2;i:399;}i:8;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:628;}i:9;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:628;}i:10;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:336:"例如，在分布式环境的不同仓库和同事讨论一次变更提交，当让需要一个明确的版本号，在不同仓库都能明确标识变更。但是在自己的仓库，指明一个提交，就可以用简单的相对名字。在git里，哈希值是最严格的绝对命名，可以在宇宙中中指明一次变更。";}i:2;i:630;}i:11;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:966;}i:12;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:968;}i:13;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:18:"绝对命名方式";i:1;i:3;i:2;i:968;}i:2;i:968;}i:14;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:968;}i:15;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:968;}i:16;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:132:"HASH 标识是严格的绝对命名释放，唯一地宇宙中指向一次变更。HASH值相同，他们的内容就是一致的。";}i:2;i:996;}i:17;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1128;}i:18;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:534:"
    $ git log -1 --pretty=oneline HEAD    
     1fbb58b4153e90eda08c2b022ee32d90729582e6 Merge git://repo.or.cz/git-gui     
     
    $ git log -1 --pretty=oneline 1fbb     
    error: short SHA1 1fbb is ambiguous.     
    fatal: ambiguous argument '1fbb': unknown revision or path         
    not in the working tree.
    Use '--' to separate paths from revisions     
                                   
    $ git log -1 --pretty=oneline 1fbb58
    1fbb58b4153e90eda08c2b022ee32d90729582e6 Merge git://repo.or.cz/git-gui 
    
 ";i:1;N;i:2;N;}i:2;i:1135;}i:19;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1135;}i:20;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:146:"另外，tag名字我们一般也任务时绝对名称，尽管tag名称不能在宇宙中使用，但每个tag名称有一个唯一的HASH1值。";}i:2;i:1680;}i:21;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1826;}i:22;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1828;}i:23;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:16:"refs 和 symrefs";i:1;i:3;i:2;i:1828;}i:2;i:1828;}i:24;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:1828;}i:25;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1828;}i:26;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:586:"ref（reference）是Git对象仓库内一个对象的哈希值。ref可能指向多个Git对象，通常指向一次提交对象。symref（symbolic reference）是直接指向git对象的一个名称，它任然是一个ref。 本地不同任务的分支，远端协作的分支，标签名都是 ref。每个 symrefs 有一个独有的，以 refs/开头的名字。每一个都被分级存放在 .git/refs/ 目录中。基本上refs有3个不同的命名空间：
refs/heads/ref   标识本地分支；
refs/remotes/ref 标识远端协作分支；
refs/tags/ref    标识所有标签";}i:2;i:1855;}i:27;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2441;}i:28;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2441;}i:29;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:412:"例如，本地有一个叫dev的分支，它简称是： refs/heads/dev。 远端协作分支可以在 refs/remotes/ 内找到它们的名字。 所以 origin/master 对应着 refs/remotes/origin/master.像v2.6.23 这样的标签， 它的SHA1值存放在 refs/tags/v2.6.23
你可以用完整的 ref 名称，也可以用它的缩写，如果分支和标签的名称相同，Git使用如下的列表来匹配。";}i:2;i:2443;}i:30;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2855;}i:31;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2855;}i:32;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:13:"     .git/ref";}i:2;i:2858;}i:33;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2871;}i:34;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:140:"   .git/refs/ref     
   .git/refs/tags/ref     
   .git/refs/heads/ref     
   .git/refs/remotes/ref     
   .git/refs/remotes/ref/HEAD
   ";}i:2;i:2871;}i:35;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2871;}i:36;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:123:"Git 里有几个特殊名字的 symrefs，他们都有专门的意义。他们都可以用来标识一次变更的提交。";}i:2;i:3025;}i:37;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3148;}i:38;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3148;}i:39;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:9:"fontcolor";i:1;a:2:{i:0;i:1;i:1;s:7:"#008080";}i:2;i:1;i:3;s:12:"<fc #008080>";}i:2;i:3151;}i:40;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:9:"fontcolor";i:1;a:2:{i:0;i:3;i:1;s:4:"HEAD";}i:2;i:3;i:3;s:4:"HEAD";}i:2;i:3163;}i:41;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:9:"fontcolor";i:1;a:2:{i:0;i:4;i:1;s:4:"#ff0";}i:2;i:4;i:3;s:5:"</fc>";}i:2;i:3167;}i:42;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3172;}i:43;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3172;}i:44;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:116:"HEAD 指的是当前分支的最新一次提交。切换分支后，它指的是新分支最新一次变更提交。";}i:2;i:3174;}i:45;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3290;}i:46;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3290;}i:47;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:9:"fontcolor";i:1;a:2:{i:0;i:1;i:1;s:7:"#008080";}i:2;i:1;i:3;s:12:"<fc #008080>";}i:2;i:3293;}i:48;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:9:"fontcolor";i:1;a:2:{i:0;i:3;i:1;s:9:"ORIG_HEAD";}i:2;i:3;i:3;s:9:"ORIG_HEAD";}i:2;i:3305;}i:49;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:9:"fontcolor";i:1;a:2:{i:0;i:4;i:1;s:4:"#ff0";}i:2;i:4;i:3;s:5:"</fc>";}i:2;i:3314;}i:50;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3319;}i:51;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3319;}i:52;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:184:"执行合并(merge）和撤销(reset)操作后，合并或者撤销前的那次全量提交被标识在这里。 你可以用 ORIG_HEAD 去覆盖或者回退本分之先前的状态。";}i:2;i:3321;}i:53;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3505;}i:54;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3505;}i:55;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:9:"fontcolor";i:1;a:2:{i:0;i:1;i:1;s:7:"#008080";}i:2;i:1;i:3;s:12:"<fc #008080>";}i:2;i:3508;}i:56;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:9:"fontcolor";i:1;a:2:{i:0;i:3;i:1;s:10:"FETCH_HEAD";}i:2;i:3;i:3;s:10:"FETCH_HEAD";}i:2;i:3520;}i:57;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:9:"fontcolor";i:1;a:2:{i:0;i:4;i:1;s:4:"#ff0";}i:2;i:4;i:3;s:5:"</fc>";}i:2;i:3530;}i:58;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3535;}i:59;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3535;}i:60;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:327:"当和远端仓库协作开发时，git 取回所有分支的更新，并存放在 .git/FETCH_HEAD。 FETCH_HEAD是快捷名称，它对应的是某分支执行fetch后，更新后的分支名称。 使用这个 symref，你可以找到git fetch后的分支的最新版。 FETCH_HEAD被合并操作覆盖，形成了MERGE_HEAD.";}i:2;i:3537;}i:61;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3864;}i:62;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3864;}i:63;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:9:"fontcolor";i:1;a:2:{i:0;i:1;i:1;s:7:"#008080";}i:2;i:1;i:3;s:12:"<fc #008080>";}i:2;i:3866;}i:64;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:9:"fontcolor";i:1;a:2:{i:0;i:3;i:1;s:10:"MERGE_HEAD";}i:2;i:3;i:3;s:10:"MERGE_HEAD";}i:2;i:3878;}i:65;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:9:"fontcolor";i:1;a:2:{i:0;i:4;i:1;s:4:"#ff0";}i:2;i:4;i:3;s:5:"</fc>";}i:2;i:3888;}i:66;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3893;}i:67;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3893;}i:68;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:110:"当执行merger操作，.git/MERGE_HEAD里列出了需要merge进来的那个分支的最近的commit sha1 。";}i:2;i:3895;}i:69;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4005;}i:70;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:4008;}i:71;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:12:"相对命名";i:1;i:3;i:2;i:4008;}i:2;i:4008;}i:72;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:4008;}i:73;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4008;}i:74;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:"Git 提供了用";}i:2;i:4031;}i:75;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:4047;}i:76;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:"^";}i:2;i:4048;}i:77;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:4049;}i:78;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:156:"和“~”的符号标识末次全量提交的快照。你可能见过master和master^。比如master^指的是到master分支上的倒数第二次提交。";}i:2;i:4050;}i:79;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4206;}i:80;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:4210;}i:81;a:3:{i:0;s:12:"document_end";i:1;a:0:{}i:2;i:4210;}}