a:183:{i:0;a:3:{i:0;s:14:"document_start";i:1;a:0:{}i:2;i:0;}i:1;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:33:"GitHub如何操作pull request？";i:1;i:3;i:2;i:1;}i:2;i:1;}i:2;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:1;}i:3;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1;}i:4;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:125:"主repo(upstream)只开放给某些人，其他人做贡献就得用pull request，让有权限的人review后merge进去 。";}i:2;i:45;}i:5;a:3:{i:0;s:9:"linebreak";i:1;a:0:{}i:2;i:170;}i:6;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:31:"
有一个仓库，叫Repo A。";}i:2;i:172;}i:7;a:3:{i:0;s:9:"linebreak";i:1;a:0:{}i:2;i:203;}i:8;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:112:"
你如果要往里贡献代码，首先要Fork这个Repo，于是在你的Github账号下有了一个Repo A2。";}i:2;i:205;}i:9;a:3:{i:0;s:9:"linebreak";i:1;a:0:{}i:2;i:317;}i:10;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:214:"
然后你在这个A2下工作，Commit，push等。
然后你希望原始仓库Repo A合并你的工作，你可以在Github上发起一个Pull Request，意思是请求Repo A的所有者从你的A2合并分支。";}i:2;i:319;}i:11;a:3:{i:0;s:9:"linebreak";i:1;a:0:{}i:2;i:533;}i:12;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:77:"
如果被审核通过并正式合并，这样你就为项目A做贡献了。";}i:2;i:535;}i:13;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:612;}i:14;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:612;}i:15;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:30:"GitHub的官方帮助如下：";}i:2;i:615;}i:16;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:645;}i:17;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:645;}i:18;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:"• ";}i:2;i:647;}i:19;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:44:"https://help.github.com/articles/fork-a-repo";i:1;s:11:"Fork A Repo";}i:2;i:651;}i:20;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:711;}i:21;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:711;}i:22;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:"• ";}i:2;i:714;}i:23;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:52:"https://help.github.com/articles/using-pull-requests";i:1;s:19:"Using Pull Requests";}i:2;i:718;}i:24;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:794;}i:25;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:794;}i:26;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:"•";}i:2;i:797;}i:27;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:55:"https://help.github.com/articles/merging-a-pull-request";i:1;s:22:"Merging a pull request";}i:2;i:800;}i:28;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:882;}i:29;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:882;}i:30;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:"•";}i:2;i:885;}i:31;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:55:"https://help.github.com/articles/closing-a-pull-request";i:1;s:22:"Closing a pull request";}i:2;i:888;}i:32;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:970;}i:33;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:970;}i:34;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:"•";}i:2;i:973;}i:35;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:57:"https://help.github.com/articles/tidying-up-pull-requests";i:1;s:25:" Tidying up Pull Requests";}i:2;i:976;}i:36;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1065;}i:37;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1065;}i:38;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:227:"发现这个官方文档写得比较简单，并没有提到开源项目协作方式的一些必要的trick（比如建立topic branch），还有Pull Request的运作细节也没有提到。写个简单的总结补充一下。";}i:2;i:1070;}i:39;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1297;}i:40;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1299;}i:41;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:21:"Step 1: Fork原项目";i:1;i:3;i:2;i:1299;}i:2;i:1299;}i:42;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:1299;}i:43;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1299;}i:44;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:93:"这个不解释了，单击一下鼠标就能做到的事情。参见GitHub帮助的原文。";}i:2;i:1330;}i:45;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1423;}i:46;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1423;}i:47;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:95:"记得用git remote add添加上游远程库的地址，否则无法追踪上游库的更新。";}i:2;i:1425;}i:48;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1520;}i:49;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1522;}i:50;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:43:"Step 2: 创建你的主题（topic）branch";i:1;i:3;i:2;i:1522;}i:2;i:1522;}i:51;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:1522;}i:52;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1522;}i:53;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:183:"这一步非常重要。GitHub的帮助里没有提到创建主题branch的必要性，你当然可以直接在原项目的默认branch（如master）上进行工作，但实际上：";}i:2;i:1575;}i:54;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1758;}i:55;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1758;}i:56;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:96:"如果打算为原项目作贡献，强烈建议你为每个主题创建一个单独的branch。";}i:2;i:1760;}i:57;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1856;}i:58;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1856;}i:59;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:72:"举例：如果需要修复原项目的一个和Unicode相关的issue：";}i:2;i:1858;}i:60;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1930;}i:61;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1930;}i:62;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:63:"$ git branch fix-unicode-error
$ git checkout fix-unicode-error";}i:2;i:1932;}i:63;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1995;}i:64;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1995;}i:65;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:80:"然后在自己的主题branch（这里是fix-unicode-error）下进行工作。";}i:2;i:1998;}i:66;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2078;}i:67;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:2080;}i:68;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:47:"Step 3: 在主题branch下完成需要的工作";i:1;i:3;i:2;i:2080;}i:2;i:2080;}i:69;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:2080;}i:70;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2080;}i:71;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:43:"记得push相应的主题branch到GitHub。";}i:2;i:2137;}i:72;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2180;}i:73;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2180;}i:74;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:42:"*（针对贡献者）rebase还是merge？";}i:2;i:2182;}i:75;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2224;}i:76;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2224;}i:77;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:173:"从实用的角度来讲，
•当你在主题branch下工作，想要导入来自上游库的（与你当前的工作不冲突的情况下）更新时，使用git rebase。";}i:2;i:2226;}i:78;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2399;}i:79;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2399;}i:80;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:51:"例如，（假设上游branch为upstream/master）";}i:2;i:2401;}i:81;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2452;}i:82;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2452;}i:83;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:46:"$ git rebase upstream/master fix-unicode-error";}i:2;i:2454;}i:84;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2500;}i:85;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2500;}i:86;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:65:"或者直接（如果当前branch已经是fix-unicode-error）：";}i:2;i:2503;}i:87;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2568;}i:88;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2568;}i:89;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:28:"$ git rebase upstream/master";}i:2;i:2570;}i:90;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2598;}i:91;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2598;}i:92;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:213:"这将把当前branch的开发“base（基础）”推进到一个新的起点，而不会引入多余的commits。
•当你在某个branch下工作时，git merge可以用来合并来自其他branch的更新。";}i:2;i:2601;}i:93;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2814;}i:94;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2814;}i:95;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:269:"如果merge的branch来自远程库，一次merge操作会增加一个额外的commit（“Merge branch 'master' of something”）。如果在一个需要发送Pull Request的主题branch下面进行这种操作，（我个人觉得）这不是一种干净的手段。";}i:2;i:2816;}i:96;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3085;}i:97;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3085;}i:98;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:199:"当你在主线branch（例如master）下进行开发时，git merge可以用来吸收其他开发branch引入的新特性（包括主项目维护者用来直接merge Pull Requests），很恰当。";}i:2;i:3087;}i:99;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3286;}i:100;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:3288;}i:101;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:35:"Step 4: 发送第一个Pull Request";i:1;i:3;i:2;i:3288;}i:2;i:3288;}i:102;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:3288;}i:103;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3288;}i:104;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:70:"GitHub的界面：左边选择base branch，右边选择head branch。";}i:2;i:3333;}i:105;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3403;}i:106;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3403;}i:107;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:276:"•base branch：相当于target branch，你希望Pull Request被merge到上游项目的哪个branch里。
◦为什么要叫base branch：base可以理解为你在进行git rebase操作时的那个“base”，也就是你的主题branch所基于的开发base（基础）。";}i:2;i:3405;}i:108;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3681;}i:109;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3681;}i:110;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:220:"•head branch：相当于source branch，你希望自己开发库里的哪个branch被用来进行Pull Request（当然也就是你的主题branch）。
◦为什么要叫head branch：参见下面关于head的定义。";}i:2;i:3684;}i:111;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3904;}i:112;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3904;}i:113;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:41:"注意head与HEAD（大写）的区别：";}i:2;i:3907;}i:114;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3948;}i:115;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3948;}i:116;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:221:"•head：简单地理解，就是指向某个commit对象的一个reference。它可以是一个branch的名称（例如，默认的master），也可以是一个tag的名称。一个库可以同时有任意多个head。";}i:2;i:3950;}i:117;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4171;}i:118;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4171;}i:119;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:254:"•HEAD：当前活动的head。在任意时刻，存在且仅存在一个HEAD。它可以是指向当前branch的head（比如，指向master，假如master是当前branch的话）；也可以不指向任何特定的branch（这叫做detached HEAD）。";}i:2;i:4174;}i:120;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4428;}i:121;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4428;}i:122;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:250:"系统会从你选择的head branch（在这里，是主题branch）的这个head开始匹配所有不包含在base branch中的commits，然后自动视作你的主题branch相对于base所增加的新特性，放进同一个Pull Request中提交。";}i:2;i:4431;}i:123;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4681;}i:124;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:4683;}i:125;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:38:"Step 5: Pull Request发送之后……";i:1;i:3;i:2;i:4683;}i:2;i:4683;}i:126;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:4683;}i:127;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4683;}i:128;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:277:"一旦你从自己的主题branch（例如fix-unicode-error）推送了一条Pull Request，那么在这条Pull Request被关闭之前，再次向这个branch里push代码，所有的commits都会被自动追加到这个Pull Request后面（不需要再另开Pull Request）。";}i:2;i:4731;}i:129;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5008;}i:130;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5008;}i:131;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:290:"这个功能尤其有用，比如你最初提交的Pull Request里存在某些问题，项目维护者要求你打回去修改；或者要求你给你的新feature添加一条相应的unit test（这种情况简直太常见了）。只要追加commits到你的这个主题branch中即可。";}i:2;i:5010;}i:132;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5300;}i:133;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5300;}i:134;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:127:"（题外话：如果原项目有Travis CI，那么它也会在每次追加push之后对Pull Request重新执行一遍测试）";}i:2;i:5302;}i:135;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5429;}i:136;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5429;}i:137;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:59:"*（针对项目维护者）cherry-pick、format-patch和am";}i:2;i:5431;}i:138;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5490;}i:139;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5490;}i:140;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:66:"这几条命令主要针对项目的维护者，稍微提一下。";}i:2;i:5492;}i:141;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5558;}i:142;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5558;}i:143;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:161:"git pull和git merge是GitHub上最常用的merge Pull Requests的方式，在命令行下merge之后，GitHub上面的Pull Request也会相应地自动关闭。";}i:2;i:5560;}i:144;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5721;}i:145;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5721;}i:146;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:276:"如果贡献者一次提交了多条commits，有些是维护者并不想要的，可以用这几条命令来选择性地手动commit。（这也适用于某些项目不是借助于GitHub的Pull Request，而是通过邮件列表和patch文件来进行协作开发的情形）";}i:2;i:5723;}i:147;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5999;}i:148;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5999;}i:149;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:102:"在这种情况下，GitHub上面的Pull Request并不能自动关闭，需要维护者手工操作。";}i:2;i:6001;}i:150;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6103;}i:151;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:6105;}i:152;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:32:"Step 6: Pull Request关闭之后";i:1;i:3;i:2;i:6105;}i:2;i:6105;}i:153;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:6105;}i:154;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6105;}i:155;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:134:"如果是已经被merge后关闭的Pull Request，你可以在页面的最下方找到一个“Delete this branch”的蓝色按钮。";}i:2;i:6147;}i:156;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6281;}i:157;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6281;}i:158;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:161:"这表明这个主题branch的历史使命已经完成（fix-unicode-error的commit已经被合并到主项目中），可以安全地从远程库中删除了。";}i:2;i:6283;}i:159;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6444;}i:160;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6444;}i:161;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:42:"在本地库中亦可删除这个branch：";}i:2;i:6446;}i:162;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6488;}i:163;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6488;}i:164;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:33:"$ git branch -d fix-unicode-error";}i:2;i:6490;}i:165;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6523;}i:166;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6523;}i:167;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:167:"反之，如果你的主题branch并没有被merge就被维护者关掉的话，你还可以继续再拿它来开新的Pull Request去骚扰主项目（´▽｀ ）。";}i:2;i:6526;}i:168;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6693;}i:169;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6693;}i:170;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:6:"总结";}i:2;i:6695;}i:171;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6701;}i:172;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6701;}i:173;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:417:"在哪些情况下可以直接使用master branch来提交Pull Request：
•你只想为主项目贡献某一处代码，贡献完自己的repo就可以扔的那种。
•你打算为主项目长期贡献代码，而且希望追随原项目的主线开发，不保留自己的特性。
•你打算为主项目长期贡献代码，默认master branch追随原项目主线，把自己的特性放到别的branch中。";}i:2;i:6703;}i:174;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:7120;}i:175;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:7120;}i:176;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:357:"在哪种情况下应该使用主题branch来提交Pull Request：
•想用master branch完全来做自己的开发。在这种情形下： ◦会从上游库合并更新，但是这些merge本身的commits显然不可能作为返还到上游库的Pull Request的一部分。
◦存在自己的（未被merge或者不想被merge到上游库的）commits。";}i:2;i:7122;}i:177;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:7479;}i:178;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:7479;}i:179;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:228:"鉴于Git的分布式开发哲学，每一个库均可以看作是一个独立的项目，显然是后一种（为每一个新特性建立一个专门的主题branch来向主项目推送Pull Request）的贡献方式更可取。";}i:2;i:7482;}i:180;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:7710;}i:181;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:7711;}i:182;a:3:{i:0;s:12:"document_end";i:1;a:0:{}i:2;i:7711;}}