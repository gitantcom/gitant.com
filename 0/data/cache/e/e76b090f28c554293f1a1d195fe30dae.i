a:278:{i:0;a:3:{i:0;s:14:"document_start";i:1;a:0:{}i:2;i:0;}i:1;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:30:"Git-flow 分支类型和模式";i:1;i:1;i:2;i:1;}i:2;i:1;}i:2;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:1;}i:2;i:1;}i:3;a:3:{i:0;s:2:"hr";i:1;a:0:{}i:2;i:43;}i:4;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:43;}i:5;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:103:"git-flow 是比较成功的一种分支模型，已经成为工业标准了。下面是详细介绍。
";}i:2;i:50;}i:6;a:3:{i:0;s:13:"internalmedia";i:1;a:7:{i:0;s:25:":git_concept:git-flow.png";i:1;s:0:"";i:2;s:6:"center";i:3;N;i:4;N;i:5;s:5:"cache";i:6;s:7:"details";}i:2;i:153;}i:7;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:0:"";}i:2;i:185;}i:8;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:186;}i:9;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:186;}i:10;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:15:"为何是Git？";i:1;i:2;i:2;i:186;}i:2;i:186;}i:11;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:186;}i:12;a:3:{i:0;s:2:"hr";i:1;a:0:{}i:2;i:212;}i:13;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:212;}i:14;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:441:"对于Git与其他集中式代码管理工具相比的优缺点的全面讨论，请参见这里。这样的争论总是喋喋不休。作为一个开发者，与现今的其他开发工具相比较，我更喜欢Git。Git真得改变了开发者对于合并和分支的思考。我曾经使用经典的CVS/Subversion，然而每次的合并/分支和其他行为总让人担惊受怕（“小心合并里的冲突，简直要命！”）。";}i:2;i:220;}i:15;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:661;}i:16;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:661;}i:17;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:318:"但是对于Git来说，这些行为非常简单和搞笑，它们被认为是日常工作中的核心部分。例如，在很多CVS/Subversion书里，分支与合并总是在后面的章节中被讨论（对于高级用户使用），然而在每个Git书中，在第3章就已经完全涵盖了（作为基础）。";}i:2;i:663;}i:18;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:981;}i:19;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:981;}i:20;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:172:"简单和重复的特性带来的结果是：分支与合并不再是什么可以害怕的东西。分支/合并被认为对于版本管理工具比其他功能更重要。";}i:2;i:983;}i:21;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1155;}i:22;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1155;}i:23;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:207:"关于工具，不再多说，让我们直接看开发模型吧。这个模型并不是如下模型：在管理软件开发进度方面，面对每个开发过程，每个队员必须按一定次序开发。";}i:2;i:1157;}i:24;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1364;}i:25;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1366;}i:26;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:24:"分布式而非集中式";i:1;i:2;i:2;i:1366;}i:2;i:1366;}i:27;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:1366;}i:28;a:3:{i:0;s:2:"hr";i:1;a:0:{}i:2;i:1400;}i:29;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1400;}i:30;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:90:"对于这种分支模型，我们设置了一个版本库，它运转良好，这是一个";}i:2;i:1406;}i:31;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:1496;}i:32;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:9:"事实上";}i:2;i:1497;}i:33;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:1506;}i:34;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:292:" 版本库。不过请注意，这个版本库只是被认为是中心版本库（因为Git是一个分布式版本管理系统，从技术上来讲，并没有一个中心版本库）。我们将把这个版本库称为原始库，这个名字对所有的Git用户来说都很容易理解。";}i:2;i:1507;}i:35;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1799;}i:36;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1799;}i:37;a:3:{i:0;s:13:"internalmedia";i:1;a:7:{i:0;s:21:":git_concept:dest.png";i:1;s:0:"";i:2;s:6:"center";i:3;N;i:4;N;i:5;s:5:"cache";i:6;s:7:"details";}i:2;i:1801;}i:38;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1829;}i:39;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1829;}i:40;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:431:"每个开发者都对origin库拉代码和提交代码。但是除了集中式的存取代码关系，每个开发者也可以从子团队的其他队友那里获得代码版本变更。例如，对于2个或多个开发者一起完成的大版本变更，为了防止过早地向origin库提交工作内容，这种机制就变得非常有用。在上述途中，有如下子团队：Alice和Bob，Alice和David，Clair和David。";}i:2;i:1831;}i:41;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2262;}i:42;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2262;}i:43;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:142:"从技术上将，这意味着，Alice创建了一个Git的远程节点，而对于Bob，该节点指向了Bob的版本库，反之亦然。  ";}i:2;i:2264;}i:44;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2407;}i:45;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:2407;}i:46;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:9:"主分支";i:1;i:2;i:2;i:2407;}i:2;i:2407;}i:47;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:2407;}i:48;a:3:{i:0;s:2:"hr";i:1;a:0:{}i:2;i:2426;}i:49;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2426;}i:50;a:3:{i:0;s:13:"internalmedia";i:1;a:7:{i:0;s:23:":git_concept:master.png";i:1;s:0:"";i:2;s:6:"center";i:3;N;i:4;N;i:5;s:5:"cache";i:6;s:7:"details";}i:2;i:2432;}i:51;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:122:"
在核心部分，研发模型很大程度上靠其他现有模型支撑的。中心库有2个可一直延续的分支：";}i:2;i:2462;}i:52;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2584;}i:53;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:2584;}i:54;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:2584;}i:55;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:2584;}i:56;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:13:" master分支";}i:2;i:2588;}i:57;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:2601;}i:58;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:2601;}i:59;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:2601;}i:60;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:2601;}i:61;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:14:" develop分支";}i:2;i:2605;}i:62;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:2619;}i:63;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:2619;}i:64;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:2619;}i:65;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2619;}i:66;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:124:"每个Git用户都要熟悉原始的master分支。与master分支并行的另一个分支，我们称之为develop分支。";}i:2;i:2621;}i:67;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2745;}i:68;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2745;}i:69;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:134:"我们把原始库/master库认作为主分支，HEAD的源代码存在于此版本中，并且随时都是一个预备生产状态。";}i:2;i:2747;}i:70;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2881;}i:71;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2881;}i:72;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:195:"我们把origin/develop库认为是主分支，该分支HEAD源码始终体现下个发布版的最新软件变更。有人称这个为“集成分支”，而这是每晚自动构建得来的。";}i:2;i:2884;}i:73;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3079;}i:74;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3079;}i:75;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:199:"当develop分支的源码到达了一个稳定状态待发布，所有的代码变更需要以某种方式合并到master分支，然后标记一个版本号。如何操作将在稍后详细介绍。";}i:2;i:3081;}i:76;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3280;}i:77;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3280;}i:78;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:279:"所以，每次变更都合并到了master，这就是新产品的定义。在这一点，我们倾向于严格执行这一点，从而，理论上，每当对master有一个提交操作，我们就可以使用Git钩子脚本来自动构建并且发布软件到生产服务器。";}i:2;i:3282;}i:79;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3561;}i:80;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:3567;}i:81;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:15:"辅助性分支";i:1;i:2;i:2;i:3567;}i:2;i:3567;}i:82;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:3567;}i:83;a:3:{i:0;s:2:"hr";i:1;a:0:{}i:2;i:3592;}i:84;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3592;}i:85;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:358:"我们的开发模型使用了各种辅助性分支，这些分支与关键分支（master和develop）一起，用来支持团队成员们并行开发，使得易于追踪功能，协助生产发布环境准备，以及快速修复实时在线问题。与关键分支不同，这些分支总是有一个有限的生命期，因为他们最终会被移除。";}i:2;i:3598;}i:86;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3956;}i:87;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3956;}i:88;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:36:"我们用到的分支类型包括：";}i:2;i:3958;}i:89;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3995;}i:90;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:3995;}i:91;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:3995;}i:92;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:3995;}i:93;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:13:" 功能分支";}i:2;i:3999;}i:94;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:4012;}i:95;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:4012;}i:96;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:4012;}i:97;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:4012;}i:98;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:13:" 发布分支";}i:2;i:4016;}i:99;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:4029;}i:100;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:4029;}i:101;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:4029;}i:102;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:4029;}i:103;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:" 热修复分支";}i:2;i:4033;}i:104;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:4049;}i:105;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:4049;}i:106;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:4049;}i:107;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4049;}i:108;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:186:"每一种分支有一个特定目的，并且受限于严格到规则，比如：可以用哪些分支作为源分支，哪些分支能作为合并目标。我们马上将进行演练。";}i:2;i:4051;}i:109;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4237;}i:110;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4237;}i:111;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:162:"从技术角度来看，这些分支绝不是特殊分支。分支的类型基于我们使用的方法来进行分类。它们理所当然是普通的Git分支。";}i:2;i:4239;}i:112;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4401;}i:113;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:4403;}i:114;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:12:"功能分支";i:1;i:3;i:2;i:4403;}i:2;i:4403;}i:115;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:4403;}i:116;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4403;}i:117;a:3:{i:0;s:13:"internalmedia";i:1;a:7:{i:0;s:24:":git_concept:feature.png";i:1;s:0:"";i:2;s:6:"center";i:3;N;i:4;N;i:5;s:5:"cache";i:6;s:7:"details";}i:2;i:4425;}i:118;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:81:"
可能是develop分支的分支版本，最终必须合并到develop分支中。";}i:2;i:4456;}i:119;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4537;}i:120;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4537;}i:121;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:98:"分支命名规则：除了master、develop、release-*、orhotfix-*之外，其他命名均可。";}i:2;i:4539;}i:122;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4637;}i:123;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4637;}i:124;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:432:"功能分支（有时被称为topic分支）通常为即将发布或者未来发布版开发新的功能。当新功能开始研发，包含该功能的发布版本在这个还是无法确定发布时间的。功能版本的实质是只要这个功能处于开发状态它就会存在，但是最终会或合并到develop分支（确定将新功能添加到不久的发布版中）或取消（譬如一次令人失望的测试）。";}i:2;i:4639;}i:125;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5071;}i:126;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5071;}i:127;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:81:"功能分支通常存在于开发者的软件库，而不是在源代码库中。";}i:2;i:5073;}i:128;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5154;}i:129;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:5158;}i:130;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:24:"创建一个功能分支";i:1;i:4;i:2;i:5158;}i:2;i:5158;}i:131;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:5158;}i:132;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5158;}i:133;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:67:"开始一项功能的开发工作时，基于develop创建分支。";}i:2;i:5190;}i:134;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5263;}i:135;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:79:"
  $ git checkout -b myfeature develop
  Switched to a new branch "myfeature"
 ";i:1;N;i:2;N;}i:2;i:5263;}i:136;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:5351;}i:137;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:34:"合并一个功能到develop分支";i:1;i:4;i:2;i:5351;}i:2;i:5351;}i:138;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:5351;}i:139;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5351;}i:140;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:82:"完成的功能可以合并进develop分支，以明确加入到未来的发布：";}i:2;i:5393;}i:141;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5481;}i:142;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:222:"
$ git checkout develop
Switched to branch 'develop'
$ git merge --no-ff myfeature
Updating ea1b82a..05e9557
(Summary of changes)
$ git branch -d myfeature
Deleted branch myfeature (was 05e9557).
$ git push origin develop
";i:1;N;i:2;N;}i:2;i:5481;}i:143;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5481;}i:144;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"--";}i:2;i:5712;}i:145;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:214:"no-ff标志导致合并操作创建一个新commit对象，即使该合并操作可以fast-forward。这避免了丢失这个功能分支存在的历史信息，将该功能的所有提交组合在一起。 比较:";}i:2;i:5714;}i:146;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5928;}i:147;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5928;}i:148;a:3:{i:0;s:13:"internalmedia";i:1;a:7:{i:0;s:28:":git_concept:merge-no-ff.png";i:1;s:0:"";i:2;N;i:3;N;i:4;N;i:5;s:5:"cache";i:6;s:7:"details";}i:2;i:5930;}i:149;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5963;}i:150;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5963;}i:151;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:255:"后一种情况，不可能从Git历史中看到哪些提交一起实现了一个功能——你必须手工阅读全部的日志信息。如果对整个功能进行回退 (比如一组提交)，后一种方式会是一种真正头痛的问题，而使用";}i:2;i:5970;}i:152;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"--";}i:2;i:6225;}i:153;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:31:"no-ffflag的情况则很容易.";}i:2;i:6227;}i:154;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6258;}i:155;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6258;}i:156;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:87:"是的，它会创建一个新的（空）提交对象，但是收益远大于开销。";}i:2;i:6260;}i:157;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6347;}i:158;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6347;}i:159;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:48:"不幸的是，我还没找到一种方法，让";}i:2;i:6349;}i:160;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"--";}i:2;i:6397;}i:161;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:71:"no-ff时作为合并操作的默认选项，但它应该是可行的。";}i:2;i:6399;}i:162;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6470;}i:163;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:6474;}i:164;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:14:"Release 分支";i:1;i:3;i:2;i:6474;}i:2;i:6474;}i:165;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:6474;}i:166;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6474;}i:167;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:144:"Release分支可能从develop分支分离而来，但是一定要合并到develop和master分支上，它的习惯命名方式为：release-*。";}i:2;i:6498;}i:168;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6642;}i:169;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6642;}i:170;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:327:"Release分支是为新产品的发布做准备的。它允许我们在最后时刻做一些细小的修改。他们允许小bugs的修改和准备发布元数据（版本号，开发时间等等）。当在Release分支完成这些所有工作以后，对于下一次打的发布，develop分支接收features会更加明确。";}i:2;i:6644;}i:171;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6971;}i:172;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6971;}i:173;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:282:"从develop分支创建新的Release分支的关键时刻是develop分支达到了发布的理想状态。至少所有这次要发布的features必须在这个点及时合并到develop分支。对于所有未来准备发布的features必须等到Release分支创建以后再合并。";}i:2;i:6973;}i:174;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:7255;}i:175;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:7255;}i:176;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:355:"在Release分支创建的时候要为即将发行版本分配一个版本号，一点都不早。直到那时，develop分支反映的变化都是为了下一个发行版，但是在Release分支创建之前，下一个发行版到底叫0.3还是1.0是不明确的。这个决定是在Release分支创建时根据项目在版本号上的规则制定的。";}i:2;i:7257;}i:177;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:7612;}i:178;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:7618;}i:179;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:25:"创建一个release分支";i:1;i:4;i:2;i:7618;}i:2;i:7618;}i:180;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:7618;}i:181;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:7618;}i:182;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:354:"Release分支是从develop分支创建的。例如，当前产品的发行版本号为1.1.5，同事我们有一个大的版本即将发行。develop 分支已经为下次发行做好了准备，我们得决定下一个版本是1.2（而不是1.1.6或者2.0）。所以我们将Release分支分离出来，给一个能够反映新版本号的分支名。";}i:2;i:7651;}i:183;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:8011;}i:184;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:311:"
	$ git checkout -b release-1.2 develop
	Switched to a new branch "release-1.2"
	$ ./bump-version.sh 1.2
	Files modified successfully, version bumped to 1.2.
	$ git commit -a -m "Bumped version number to 1.2"
	[release-1.2 74d9424] Bumped version number to 1.2
	1 files changed, 1 insertions(+), 1 deletions(-)
";i:1;N;i:2;N;}i:2;i:8011;}i:185;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:8011;}i:186;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:198:"创建新分支以后，切换到该分支，添加版本号。这里，bump-version.sh 是一个虚构的shell脚本，它可以复制一些文件来反映新的版本（这当然可以手动改变";}i:2;i:8331;}i:187;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"--";}i:2;i:8529;}i:188;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:63:"目的就是修改一些文件）。然后版本号被提交。";}i:2;i:8531;}i:189;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:8594;}i:190;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:8594;}i:191;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:316:"这个新分支可能会存在一段时间，直到该发行版到达它的预定目标。在此期间，bug的修复可能被提交到该分支上（而不是提交到develop分支上）。在这里严格禁止增加大的新features。他们必须合并到develop分支上，然后等待下一次大的发行版。";}i:2;i:8596;}i:192;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:8912;}i:193;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:8915;}i:194;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:25:"完成一个release分支";i:1;i:4;i:2;i:8915;}i:2;i:8915;}i:195;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:8915;}i:196;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:8915;}i:197;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:461:"当一个release分支准备好成为一个真正的发行版的时候，有一些工作必须完成。首先，release分支要合并到master上（因为每一次提交到master上的都是一个新定义的发行版，记住）。然后，提交到master上必须打一个标签，以便以后更加方便的引用这个历史版本。最后，在release分支上的修改必须合并到develop分支上，以便未来发行版也包含这些bugs的修复。";}i:2;i:8948;}i:198;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:9409;}i:199;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:9409;}i:200;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:27:"在Git中的前两步是：";}i:2;i:9411;}i:201;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:9444;}i:202;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:152:"
	$ git checkout master
	Switched to branch 'master'
	$ git merge --no-ff release-1.2
	Merge made by recursive.
	(Summary of changes)
	$ git tag -a 1.2
";i:1;N;i:2;N;}i:2;i:9444;}i:203;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:9444;}i:204;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:60:"发行版现在已经完成，为以后引用打上标签。";}i:2;i:9605;}i:205;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:9665;}i:206;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:9665;}i:207;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:74:"编辑：你可能也想使用the-sor-u <key>flags来标记你的标签。";}i:2;i:9667;}i:208;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:9741;}i:209;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:9741;}i:210;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:104:"为了是修改保持在release分支上，我们需要合并这些到develop分支上去，在Git上：";}i:2;i:9743;}i:211;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:9853;}i:212;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:136:"
	$ git checkout develop
	Switched to branch 'develop'
	$ git merge --no-ff release-1.2
	Merge made by recursive.
	(Summary of changes)
";i:1;N;i:2;N;}i:2;i:9853;}i:213;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:9853;}i:214;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:129:"这个步骤可能会导致合并冲突（可能由于改变版本号更是如此）。如果是这样，修复它然后提交。";}i:2;i:9998;}i:215;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10127;}i:216;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10127;}i:217;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:100:"现在我们真正的完成了，这个release分支将被删除，因为我们不再需要它了。";}i:2;i:10129;}i:218;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10235;}i:219;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:75:"
	$ git branch -d release-1.2
	Deleted branch release-1.2 (was ff452fe).
	
";i:1;N;i:2;N;}i:2;i:10235;}i:220;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:10321;}i:221;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:15:"热修复分支";i:1;i:3;i:2;i:10321;}i:2;i:10321;}i:222;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:10321;}i:223;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10321;}i:224;a:3:{i:0;s:13:"internalmedia";i:1;a:7:{i:0;s:23:":git_concept:hotfix.png";i:1;s:0:"";i:2;s:6:"center";i:3;N;i:4;N;i:5;s:5:"cache";i:6;s:7:"details";}i:2;i:10345;}i:225;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:95:"
可以基于master分支，必须合并回develop和master分支。
分支名约定：hotfix-*";}i:2;i:10375;}i:226;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10470;}i:227;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10470;}i:228;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:303:"热修复分支与发布分支很相似，他们都为新的生成环境发布做准备，尽管这是未经计划的。他们来自生产环境的处于异常状态压力。当生成环境验证缺陷必须马上修复是，热修复分支可以基于master分支上对应与线上版本的tag创建。";}i:2;i:10472;}i:229;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10775;}i:230;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10775;}i:231;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:124:"其本质是团队成员（在develop分支上）的工作可以继续，而另一个人准备生产环境的快速修复。";}i:2;i:10777;}i:232;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10901;}i:233;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:10904;}i:234;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:21:"创建修补bug分支";i:1;i:4;i:2;i:10904;}i:2;i:10904;}i:235;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:10904;}i:236;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10904;}i:237;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:337:"hotfix branch(修补bug分支)是从Master分支上面分出来的。例如，1.2版本是当前生产环境的版本并且有bug。但是开发分支（develop）变化还不稳定。我们需要分出来一个修补bug分支（hotfix branch）来解决这种情况。
1	$ git checkout -b hotfix-1.2.1 master
2	Switched to a new branch ";}i:2;i:10933;}i:238;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:11270;}i:239;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:12:"hotfix-1.2.1";}i:2;i:11271;}i:240;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:11283;}i:241;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:106:"
3	$ ./bump-version.sh 1.2.1
4	Files modified successfully, version bumped to 1.2.1.
5	$ git commit -a -m ";}i:2;i:11284;}i:242;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:11390;}i:243;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:30:"Bumped version number to 1.2.1";}i:2;i:11391;}i:244;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:11421;}i:245;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:107:"
6	[hotfix-1.2.1 41e61bb] Bumped version number to 1.2.1
7	1 files changed, 1 insertions(+), 1 deletions(-)";}i:2;i:11422;}i:246;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:11529;}i:247;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:11529;}i:248;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:66:"分支关闭的时侯不要忘了更新版本号(bump the version)";}i:2;i:11531;}i:249;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:11597;}i:250;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:11597;}i:251;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:79:"然后，修复bug，一次提交或者多次分开提交。
1	$ git commit -m ";}i:2;i:11599;}i:252;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:11678;}i:253;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:31:"Fixed severe production problem";}i:2;i:11679;}i:254;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:11710;}i:255;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:110:"
2	[hotfix-1.2.1 abbe5d6] Fixed severe production problem
3	5 files changed, 32 insertions(+), 17 deletions(-)";}i:2;i:11711;}i:256;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:11821;}i:257;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:11825;}i:258;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:24:"完成一个hotfix分支";i:1;i:4;i:2;i:11825;}i:2;i:11825;}i:259;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:11825;}i:260;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:11825;}i:261;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:197:"完成一个bugfix之后，需要把butfix合并到master和develop分支去，这样就可以保证修复的这个bug也包含到下一个发行版中。这一点和完成release分支很相似。";}i:2;i:11857;}i:262;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:12054;}i:263;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:12054;}i:264;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:134:"首先，更新master并对release打上tag：
view source
print?
1	$ git checkout master
2	Switched to branch 'master'
3	$ git merge ";}i:2;i:12056;}i:265;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"--";}i:2;i:12190;}i:266;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:169:"no-ff hotfix-1.2.1
4	Merge made by recursive.
5	(Summary of changes)
6	$ git tag -a 1.2.1
编辑：你可能也会想使用 -sor-u <key>参数来对你的tag进行加密";}i:2;i:12192;}i:267;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:12361;}i:268;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:12361;}i:269;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:120:"下一步，把bugfix添加到develop分支中：
1	$ git checkout develop
2	Switched to branch 'develop'
3	$ git merge ";}i:2;i:12363;}i:270;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"--";}i:2;i:12483;}i:271;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:473:"no-ff hotfix-1.2.1
4	Merge made by recursive.
5	(Summary of changes)
规则的一个例外是： 如果一个release分支已经存在，那么应该把hotfix合并到这个release分支，而不是合并到develop分支。当release分支完成后， 将bugfix分支合并回release分支也会使得bugfix被合并到develop分支。（如果在develop分支的工作急需这个bugfix，等不到release分支的完成，那你也可以把bugfix合并到develop分支）";}i:2;i:12485;}i:272;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:12958;}i:273;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:12958;}i:274;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:106:"最后，删除临时分支：
1	$ git branch -d hotfix-1.2.1
2	Deleted branch hotfix-1.2.1 (was abbe5d6).";}i:2;i:12960;}i:275;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:13066;}i:276;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:13066;}i:277;a:3:{i:0;s:12:"document_end";i:1;a:0:{}i:2;i:13066;}}