======中央集中式开发流程======

{{ :git_branch_model:git-workflow-svn.png |Git Workflows: SVN-style Workflow}}

Transitioning to a distributed version control system may seem like a daunting task, but you don’t have to change your existing workflow to take advantage of Git. Your team can develop projects in the exact same way as they do with Subversion.

<fc #0000EE>对于git的新特性，迁移到分布式版本控制系统似乎让气馁。那么你可以像SVN的工作流程使用git，这样就可以使用git的新功能而不必调整现有的工作流程。</fc>

However, using Git to power your development workflow presents a few advantages over SVN. First, it gives every developer their own local copy of the entire project. This isolated environment lets each developer work independently of all other changes to a project—they can add commits to their local repository and completely forget about upstream developments until it's convenient for them.

<fc #0000EE>尽管如此，git还是比svn有2个好处：
1、工程师在本地有整个项目的代码。</fc>

Second, it gives you access to Git’s robust branching and merging model. Unlike SVN, Git branches are designed to be a fail-safe mechanism for integrating code and sharing changes between repositories.

<fc #0000EE>
2、可以方便使用git的分支模式。</fc>

=====工作机制=====

Like Subversion, the Centralized Workflow uses a central repository to serve as the single point-of-entry for all changes to the project. Instead of trunk, the default development branch is called master and all changes are committed into this branch. This workflow doesn’t require any other branches besides master.
<fc #0000EE>
像svn一样，集中式工作流程使用了一个集中的仓库作为一个单点。 现对于trunk， git使用master收集所有提交到他的分支。 这种模式除了mater不需要其他分支。</fc>

Developers start by cloning the central repository. In their own local copies of the project, they edit files and commit changes as they would with SVN; however, these new commits are stored locally—they’re completely isolated from the central repository. This lets developers defer synchronizing upstream until they’re at a convenient break point.

<fc #0000EE>开发者从克隆中央集中的仓库开始工作。 在本地，开发者有整个项目的代码，就像svn一样，工程师编辑并提交代码；然而，新的提交被存到本地。 这让开发者能够在一个合适的时节才去提交本地代码。</fc>

To publish changes to the official project, developers “push” their local master branch to the central repository. This is the equivalent of svn commit, except that it adds all of the local commits that aren’t already in the central master branch.

<fc #0000EE>提交本地代码到中央仓库，开发者需要"push"本地master上的代码到中央仓库的master上。这步相当于“svn commit”，</fc>

{{:git_branch_model:git-workflow-svn-push-local.png |}}

====解决冲突====

The central repository represents the official project, so its commit history should be treated as sacred and immutable. If a developer’s local commits diverge from the central repository, Git will refuse to push his changes because this would overwrite official commits.

<fc #0000EE>中央仓库一般是官方的代码库了，所以要认真和严肃点。本地开发和中央仓库代码不一致，git就不允许提交本地变更到中央，这样你就破坏了官方的版本。</fc>

Before the developer can publish his feature, he needs to fetch the updated central commits and rebase his changes on top of them. This is like saying, “I want to add my changes to what everyone else has already done.” The result is a perfectly linear history, just like in traditional SVN workflows.

<fc #0000EE>在工程师能向中央库提交代码前，他需要先从中央库取回其他人的提交，并且在本人的基础上rebase自己的提交。这等于说， 我想增加变更”。这使得仓库的历史是线性的，就像传统的svn的工作流。</fc>

If local changes directly conflict with upstream commits, Git will pause the rebasing process and give you a chance to manually resolve the conflicts. The nice thing about Git is that it uses the same git status and git add commands for both generating commits and resolving merge conflicts. This makes it easy for new developers to manage their own merges. Plus, if they get themselves into trouble, Git makes it very easy to abort the entire rebase and try again (or go find help).
  
<fc #0000EE>如果本地变更直接与上游提交冲突，git将暂停rebase过程，并让工程师手动解决冲突。git 比较高级的是用 git status 和 git add 的命令解决合并冲突。 新人方便的合并冲突。如果合并陷入麻烦，git中断整个衍和，然后再来一次合并操作。</fc>

=====演示=====
  
Let’s take a step-by-step look at how a typical small team would collaborate using this workflow. We’ll see how two developers, John and Mary, can work on separate features and share their contributions via a centralized repository.

<fc #0000EE>让我们一步步地演示如何使用这个流程吧。看看两个工程师 John和Mary如何在中央集中仓库完成功能开发和协作。</fc>

====初始化中央项目仓库====
  
{{ :git_branch_model:git-workflow-svn-initialize.png |Git Workflows: Initialize Central Bare Repository}}

First, someone needs to create the central repository on a server. If it’s a new project, you can initialize an empty repository. Otherwise, you’ll need to import an existing Git or SVN repository.

Central repositories should always be bare repositories (they shouldn’t have a working directory), which can be created as follows:

<code>
ssh user@host
git init --bare /path/to/repo.git
</code>
Be sure to use a valid SSH username for user, the domain or IP address of your server for host, and the location where you'd like to store your repo for /path/to/repo.git. Note that the .git extension is conventionally appended to the repository name to indicate that it’s a bare repository.
  
====项目成员克隆中央仓库====
  
{{ :git_branch_model:git-workflow-svn-clone.png |Git Workflows: Clone Central Repo}}

Next, each developer creates a local copy of the entire project. \\
<fc #0000EE>项目成员创建本地库。</fc>
This is accomplished via the git clone command:
<code>  
git clone ssh://user@host/path/to/repo.git
</code>   
When you clone a repository, Git automatically adds a shortcut called origin that points back to the “parent” repository, under the assumption that you'll want to interact with it further on down the road.

<fc #0000EE>你克隆中央库，Git自动创建一个名称origin指向远端仓库。</fc>
   
====John 在本地开发新功能====
  
{{ :git_branch_model:git-workflow-svn-1.png |Git Workflows: Edit Stage Commit Feature Process}}

In his local repository, John can develop features using the standard Git commit process: edit, stage, and commit. If you’re not familiar with the staging area, it’s a way to prepare a commit without having to include every change in the working directory. This lets you create highly focused commits, even if you’ve made a lot of local changes.
<code>
git status # View the state of the repo
git add # Stage a file
git commit # Commit a file
</code>
Remember that since these commands create local commits, John can repeat this process as many times as he wants without worrying about what’s going on in the central repository. This can be very useful for large features that need to be broken down into simpler, more atomic chunks.
  
====Mary 在本地修改她的代码====
  
{{ :git_branch_model:git-workflow-svn-2.png |Git Workflows: Edit Stage Commit Feature}}

Meanwhile, Mary is working on her own feature in her own local repository using the same edit/stage/commit process. Like John, she doesn’t care what’s going on in the central repository, and she really doesn’t care what John is doing in his local repository, since all local repositories are private.  
  
====John 提交他的代码====
  
{{ :git_branch_model:git-workflow-svn-3.png |Git Workflows: Publish Feature}}

Once John finishes his feature, he should publish his local commits to the central repository so other team members can access it. He can do this with the git push command, like so:

<fc #0000EE>John完成了代码开发，他想把代码提交中央项目库，可以执行如下命令：</fc>

<code>
git push origin master
</code>
Remember that origin is the remote connection to the central repository that Git created when John cloned it. The master argument tells Git to try to make the origin’s master branch look like his local master branch. Since the central repository hasn’t been updated since John cloned it, this won’t result in any conflicts and the push will work as expected. 

<fc #0000EE>origin 是执行clone时，系统默认名称，指向远端中心仓库的master分支。这样 想 origin master 提交，就想对本地master提交的动作一样。 在John 克隆中央仓库，在本地修改后，还没人提交过新代码，所以John 的push动作不会有冲突，而且提交动作会顺利执行。</fc>
   
====Mary 尝试提交她的代码====
 {{ :git_branch_model:git-workflow-svn-4.png | Git Workflows: Push Command Error}}

Let’s see what happens if Mary tries to push her feature after John has successfully published his changes to the central repository. She can use the exact same push command:

<fc #0000EE>在John成功向中央项目仓库提交他的变更后，Mary 也要向项目库提交代码，她是这样做的：</fc>

<code>
git push origin master
</code>

But, since her local history has diverged from the central repository, Git will refuse the request with a rather verbose error message:

<fc #0000EE>然而，她本地的Git历史已经和中央项目库分叉了，Git 拒绝合并，并给出了详细的出错信息：</fc>


<code>
error: failed to push some refs to '/path/to/repo.git'
hint: Updates were rejected because the tip of your current branch is behind
hint: its remote counterpart. Merge the remote changes (e.g. 'git pull')
hint: before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.
</code>

This prevents Mary from overwriting official commits. She needs to pull John’s updates into her repository, integrate them with her local changes, and then try again.   
  
<fc #0000EE>拒绝的目的是防止Mary 覆盖该其他人已有的提交。 Mary 需要首先从中央项目库中取回（pull)John的变更，合并到自己的本地库中。  </fc>
====Mary 衍合（变基）John的变更 rebases on top of John’s commit(s)====
 {{ :git_branch_model:git-workflow-svn-5.png |Git Workflows: Git Pull Rebase}}

Mary can use git pull to incorporate upstream changes into her repository. This command is sort of like svn update—it pulls the entire upstream commit history into Mary’s local repository and tries to integrate it with her local commits:

<fc #0000EE>Mary 能用git pull 合并变更到本地库。 这个有点像 svn 的update 去合并所有的变更到Mary本地目录一样。</fc>


<code>
git pull --rebase origin master
</code>

The --rebase option tells Git to move all of Mary’s commits to the tip of the master branch after synchronising it with the changes from the central repository, as shown below:

<fc #0000EE>The --rebase选项告诉git在同步本地和中心仓库的提交后，移动所有Mary的提交到主干分支的顶端。</fc>

{{ :git_branch_model:git-workflow-svn-6.png |}}

The pull would still work if you forgot this option, but you would wind up with a superfluous “merge commit” every time someone needed to synchronize with the central repository. For this workflow, it’s always better to rebase instead of generating a merge commit.

<fc #0000EE>如果没有rebase选项，pull可能任然工作，那就会产生合并提交。 对于git的流程来说，用rebase合并而不是一次合并提交，会让合并历史更清晰。</fc>


====Mary 解决合并冲突====

{{ :git_branch_model:git-workflow-svn-7.png |
Git Workflows: Rebasing on Commits}}

Rebasing works by transferring each local commit to the updated master branch one at a time. This means that you catch merge conflicts on a commit-by-commit basis rather than resolving all of them in one massive merge commit. This keeps your commits as focused as possible and makes for a clean project history. In turn, this makes it much easier to figure out where bugs were introduced and, if necessary, to roll back changes with minimal impact on the project.

<fc #0000EE> 衍合就是把每次本地提交都表现到主分支上。这样你能发现每次本地提交与远端主干发生了什么样的冲突，而不是在一次合并提交时，解决所有人大量的合并冲突。这样做，就把你在本地对项目的改变历史也体现在中央仓库历史上。 而且，这样可以方便地找到缺陷是生么时候带进来的。回退的时候可以只会有错误代码，无关其他代码的合并。</fc>

If Mary and John are working on unrelated features, it’s unlikely that the rebasing process will generate conflicts. But if it does, Git will pause the rebase at the current commit and output the following message, along with some relevant instructions:

<fc #0000EE>如果Mary 和 John  开发的代码相关性不大，那么衍和(rebase)过程中产生冲突的可能性不大。如果发生了冲突，Git 会暂停衍合在出现问题的提交上，并给出相关的指示：</fc>

<code>
CONFLICT (content): Merge conflict in <some-file>
</code>

{{ :git_branch_model:git-workflow-svn-8.png |}}

The great thing about Git is that anyone can resolve their own merge conflicts. In our example, Mary would simply run a git status to see where the problem is. Conflicted files will appear in the Unmerged paths section:

<fc #0000EE>Git 的特点之一就是任何人都可以自己解决合并冲突。Mary 只是运行 "git status" 就可以知道合并时问题出在那里，合并失败的文件会明白的告诉你:</fc>

<code>
# Unmerged paths:
# (use "git reset HEAD <some-file>..." to unstage)
# (use "git add/rm <some-file>..." as appropriate to mark resolution)
#
# both modified: <some-file>>
</code>
Then, she’ll edit the file(s) to her liking. Once she’s happy with the result, she can stage the file(s) in the usual fashion and let git rebase do the rest:

<fc #0000EE>接着，Mary 修改文件，如果修改结果测试正确，她就会git add 这个文件，然后继续执行rebase的合并操作。</fc>

<code>
git add <some-file>
git rebase --continue </some-file>
</code>

And that’s all there is to it. Git will move on to the next commit and repeat the process for any other commits that generate conflicts.

<fc #0000EE>这就是全部，Git继续合并提交，直到遇见下一次合并冲突。 </fc>



If you get to this point and realize and you have no idea what’s going on, don’t panic. Just execute the following command and you’ll be right back to where you started before you ran git pull --rebase:

<fc #0000EE>也许你不理解，不想继续执行这种合并。不要怕，只要执行下面的命令，你就回到刚开始执行合并时的状态：</fc>

<code>
git rebase --abort
</code>
 
====Mary成功向项目仓库提交代码====

{{ :git_branch_model:git-workflow-svn-9.png |Git Workflows: Synchronize Central Repo}}

After she’s done synchronizing with the central repository, Mary will be able to publish her changes successfully:

<fc #0000EE>在执行完同步命令后，Mary就可以提交她的代码了，如下命令：</fc>

<code>
git push origin master
</code>
=====继续前进=====

As you can see, it’s possible to replicate a traditional Subversion development environment using only a handful of Git commands. This is great for transitioning teams off of SVN, but it doesn’t leverage the distributed nature of Git.\\
<fc #0000EE>
如上所述，只用了几个git命令，我们就实现了SVN的工作流程。这方便了熟悉SVN的团队，但是这并没有利用到Git的分布式特性。</fc>

If your team is comfortable with the Centralized Workflow but wants to streamline its collaboration efforts, it's definitely worth exploring the benefits of the Feature Branch Workflow. By dedicating an isolated branch to each feature, it’s possible to initiate in-depth discussions around new additions before integrating them into the official project.


如果你的团队是舒适与集中式工作流但希望简化其合作的努力，这绝对是值得探索的特性分支工作流的好处。通过一个孤立的分支的每个特征，进行深入的讨论在新增加的前将他们整合到正式的项目是可能的。